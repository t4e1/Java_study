생성자 / dto / overloading / parameter / static / singleton / 초기화 블록 / 객체 배열 




call by value : 
call by reference :

-> call by value 로 받아온 값은 메소드 내에서 수정을 해도 원본 변수가 영향을 받지 않는다. 
-> call by reference 로 받아온 값은 메소드 내에서 수정을 가하면 원본이 영향을 받는다.  

생성자
생성자를 활용해야지만 객체가 생성된다. 
안만들었어도 기본 생성자는 자동 생성된다. 
new 라는 연산자를 쓰면 클래스를 써서 객체가 생성된다. 

this. 은 생성자를 통해 생성될 객체 , 
this(); 는 같은 클래스의 다른 생성자 -> 코드의 간결화 이외의 목적은 없음  


DTO 
자바빈 = '클래스를 작성하는 규칙' 
자바빈 작성 규칙 알아두기 


overloading 
시그니처가 달라서 그렇지, test를 위한 메소드를 만들자 ( 기능은 하나 )
-> 재료가 달라져도 기능은 하나니까 하나의 이름으로 여러 재료를 받을 수 있도록 함 
-> 이름이 똑같은 이유 ? : 기능이 똑같기 때문 
오버로딩 가능한 조건 : 시그니처 (타입 개수 순서)를 달리한다 

parameter 종류 
기본자료형은 값을 던지는거 -> 던진 후엔 영향 x 
이외의 매개변수 -> 던진 후에도 영향 o ( call by value vs call by reference ) 
가변인자도 던질 수 있지만 안쓰는게 좋다. 

singleton 
static을 활용해서 객체가 하나만 생성되게 하는것 -> 메모리 낭비 방지 목적 
singletone 을 만드는 방식 2가지 ( eager / lazy ) 

static 
별도의 공유를 목적으로 하는 공간을 활용하는것. 변수나 메소드 다 가능하다. 
객체가 달라지더라도 static 붙은 얘들은 전부 공유가 된다. 

초기화 블럭
필드와 생성자 중간에 위치. 
어떤 생성자든지 공통되게 해야할 작업이 있으면 초기화 블럭에 기입한다. 
객체 생성의 과정 : JVM -> 필드 -> 초기화블럭 -> 생성자 
** 필드에 알고리즘 써도 실행안됨

객체 배열
변수 하나만 가지고 여러 객체를 관리하자. (다차원 배열과 비슷하다) 
각 객체의 주소를 관리하는게 객체 배열 




 