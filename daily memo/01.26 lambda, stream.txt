람다 / 스트림

생성자로 초기화 받을 것인지, 세터를 통해서 초기화 할것인지 
-> 둘다 가능하지만 개발이 잦고 고도화가 잦으면 세터를 사용, 그게 아니면 생성자 사용 

signUP 이라는 하나의 타입으로 뭉치는 이유 
:입력 받을 매개변수가 늘어난다 -> 코딩 간결화가 안됨 
하나의 변수라도 수정이 일어나면 관련된 클래스들이 전부 에러가 발생 



회원 번호 추가: 
1. 마지막 회원의 번호 조회 
2. 회원번호에 setter로 +1 시키는 auto increment 기능 추가 
3. repository에 정보를 넘겨서 DB에 등록
4. 등록할 때는 기존에 있는 객체도 업데이트 하기 
5. 

람다 
: 자바가 자바스크립트를 흉내냄 ( 함수지향언어를 자바에 녹여내려함 ) 

자바스크립트 : 프로토타입 기반의 객체 지향 언어, 함수지향 프로그래밍 언어,
동적타입(var, let, const)-> 1을 넣으면 내부에서 알아서 int로 변경 
-> 기능이 많다. 
=> 이런 기능이 많아서 java가 부족한 부분을 채우기 위해 javascript를 흉내내서 함수지향적인 느낌으로 만든게 람다식 

1. 함수에 이름이 없다. -> 한 번 사용하고 버리겠다는 의미 ( 익명 함수 Anonymous Function ) 
2. 대입/리턴의 개념을 줄임 
-> 함수이름도 없고 리턴도 없지만 메소드 처럼 작동 
public int method(int x, int y ) {
return x * y;
}
-> (int x, int y ) -> x * y;

단순하고 편함 ( 익숙해지면 ) 

어떻게 흉내를 내는지? 

인터페이스인데 추상메소드가 하나인 것을 functionalInterface 라고 함
-> 이런 인터페이스인것만 람다식을 사용 가능 

장점 : 편리하고 단순함 
단점 : 러닝커브가 높고, 원래 어떤 모양이었는지 추측하기가 쉽지 않다. 

인터페이스 안에 funtionalInterface 사용 가능 


람다식 -> 남이 만들어놓은 메소드나 API의 메소드를 호출하면서 매개변수가 지정되어 있을 때 
매개변수에 람다식을 사용 


스트림 
병렬처리 가능하게 도와줌 
배열 / 컬렉션을 다루기 쉽게 해주는 용법

동기화 vs 병렬 
동기화 : 한번에 많이 몰리면 줄을 세워서 순서대로 하나씩 처리  -> stream
병렬 : 동시에 여러개의 작업을 진행 (리소스를 많이 잡아먹지만 빠르게 처리 가능) -> parallel stream 

Stream 을 만드는 방법
1. Array 2. ArrayList 3.Builder 4.iterator 를 사용하여 생성 

filter: 반환값이 true가 되는 요소는 통과, false는 걸러주는 메소드. 모든 stream 타입이 다 가지고 있다. 
반환형이 반드시 boolean 형이 되어야 한다. 
map : 스트림에 들어있는 데이터를 람다식으로 가공하고 새로운 스트림에 담아주는 메소드 

