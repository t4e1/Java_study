상속 / super key  / overriding / 다형성 / 동적바인딩 / 추상클래스




상속 
부모가 자식에게 물려주는 DNA (멤버 - 필드, 메소드 ). 단, 생성자는 물려주지 않는다. 
자식 클래스는 부모로 부터 물려받은 기질 외에도 추가적으로 뭔가를 더 가질 수 있다.

 왜 물려주는지? 
1. 자식 클래스의 코드상에는 부모 클래스에서 보이는 멤버 정보가 안적혀 있다. -> 코드의 간결화 
2. 다형성의 토대가 된다.

자바 상속은 단일상속 ( 자식 클래스는 하나의 부모 클래스만, 부모 클래스는 여러 자식 클래스도 가능 ) 

재정의한다 - 물려받은 기능(메소드)를 자식 클래스에 맞게 변경하는 것 

@Override  (어노테이션)
1. 가독성의 의미 ( 부모로 부터 물려받은 메소드임을 한번에 알 수 있음 ) 
2. 부모로 부터 물려받았는데 뭔가를 잘못 쓰지 않았는지를 알려줌 ( ) 


super
super. : 자식 클래스 타입의 객체가 생성될 때, 먼저 생성된 부모 클래스 타입의 객체의 주소값(참조값)을 통해 접근
spuer() : 부모로부터 물려받지 못한 생성자를 부모 클래스에 있는 생성자를 활용하기 위해 사용


overriding 


다형성  = 자료형이 많다
다형성을 생각할 때는 항상 상속을 전제로 생각한다. 
자식으로 갈수록 많은 자료형을 가진다. -> 최상위 부모 클래스의 타입 하나로 하위에 연결된 모든 자식 클래스를 관리 가능하다. 
ex) 오케스트라를 생각. 지휘자 = 최상위 클래스, 자식 클래스 = 각각 다른 연주자,  최상위 클래스에서 '연주해라' 라고 명령 -> 모두가 각자의 스타일대로 연주하게 된다. 
-> 한줄의 코딩으로 여러 객체에 작업을 수행하게 할 수 있다. 
부모는 자식 클래스로 변할 수 없지만, 자식은 부모 클래스로 변할 수 있다. 
B -> A 일 경우, (A a = new B 불가능, B b = new A 가능) 

정적바인딩 : 컴파일 시점에 인식하고 있는 상태,   
동적바인딩 : 런타임 시점에 동적바인딩 발생, 런타임 시점에 자식에 오버라이딩된 메소드를 찾아서 오버라이딩 된 메소드가 있으면 그걸 실행하는 것  
동적바인딩의 조건
조건 1. 상속 관계여야한다
	2. 오버라이딩 되어있어야함 


추상클래스 
객체를 생성할 수 없는 클래스 
일반적으로는 객체를 생성할 수 없지만, 자식 클래스를 
추상 클래스를 상속받은 자식 클래스가 오버라이드를 통해 완전한 메소드를 만든다면, 자식은 추상 클래스가 아니다 
추상 클래스는 추상 메소드를 0개이상 가진다 ( 추상 메소드가 없어도 추상 클래스는 선언 가능 ) 


-> ??? 추상 클래스는 어느 경우에 사용하는지? (객체를 만들고 싶지 않을 경우? 그러면 final을 쓰면 되는게 아닌지? ) 
-> ???2 추상 메소드는 왜 사용하는지?? 추상 메소드가 없어도 추상 클래스는 선언 가능한데, 메소드로 객체를 만드는 경우가 있는지? 

사용하는 이유 : '규약' 
-> 나를 상속 받을 자식 클래스는 반드시 메소드를 오버라이딩해서 완전한 클래스로 구현해라 (일종의 제약조건) 
-> 자식 클래스라면 반드시 가져야 하는 

추상 클래스는 API를 만들 때 주로 쓴다. (ArrayList -> AbstractCollection 인데, ArrayList 말고 비슷한 다른 API를 만들고 싶다 : AbstractCollection 에서 상속받아서 만들 수 있음)  

